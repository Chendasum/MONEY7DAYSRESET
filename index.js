require("dotenv").config();

const express = require("express");
const TelegramBot = require("node-telegram-bot-api");
const cron = require("node-cron");

console.log("üöÄ Starting 7-Day Money Flow Bot (Railway Version)...");
console.log("BOT_TOKEN exists:", !!process.env.BOT_TOKEN);
console.log("PORT:", process.env.PORT || 5000);

// Initialize Express app first
const app = express();
app.use(express.json({ limit: "10mb", charset: "utf-8" }));
app.use(express.urlencoded({ extended: true, charset: "utf-8" }));

// Set UTF-8 headers for all outgoing responses
app.use((req, res, next) => {
  res.setHeader("Content-Type", "application/json; charset=utf-8");
  next();
});

// === DATABASE MODELS - WITH FALLBACK ===
let User = {
  findOne: async () => null,
  findOneAndUpdate: async (filter, update, options) => null
};

let Progress = {
  findOne: async () => null,
  findOneAndUpdate: async (filter, update, options) => null
};

// Try to load real models if available
try {
  const UserModel = require("./models/User");
  const ProgressModel = require("./models/Progress");
  User = UserModel;
  Progress = ProgressModel;
  console.log("‚úÖ Database models loaded");
} catch (error) {
  console.log("‚ö†Ô∏è Using fallback database models");
}

// === IMPORT COMMAND MODULES - WITH FALLBACK ===
let startCommand = { handle: async (msg, bot) => { 
  await bot.sendMessage(msg.chat.id, "Bot starting..."); 
}};
let dailyCommands = { handle: async (msg, match, bot) => { 
  await bot.sendMessage(msg.chat.id, "Daily content coming soon..."); 
}};
let paymentCommands = { 
  pricing: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Pricing info..."); },
  instructions: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Payment instructions..."); }
};
let vipCommands = { info: async (msg, bot) => { 
  await bot.sendMessage(msg.chat.id, "VIP info..."); 
}};
let adminCommands = {
  showUsers: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Admin users..."); },
  showAnalytics: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Analytics..."); },
  checkProgress: async (msg, match, bot) => { await bot.sendMessage(msg.chat.id, "Progress check..."); },
  showActivity: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Activity..."); },
  showFollowup: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Followup..."); }
};
let quotesCommands = { 
  random: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Quote..."); },
  categories: async (msg, bot) => { await bot.sendMessage(msg.chat.id, "Categories..."); }
};
let badgesCommands = { show: async (msg, bot) => { 
  await bot.sendMessage(msg.chat.id, "Badges..."); 
}};

// Try to load real command modules if available
try {
  startCommand = require("./commands/start");
  dailyCommands = require("./commands/daily");
  paymentCommands = require("./commands/payment");
  vipCommands = require("./commands/vip");
  adminCommands = require("./commands/admin");
  quotesCommands = require("./commands/quotes");
  badgesCommands = require("./commands/badges");
  console.log("‚úÖ Command modules loaded");
} catch (error) {
  console.log("‚ö†Ô∏è Using fallback command modules");
}

// === IMPORT SERVICE MODULES - WITH FALLBACK ===
let AccessControl = class {
  async checkAccess(userId) { return { hasAccess: true, tier: 'free' }; }
  async getTierSpecificHelp(userId) { return "Help content..."; }
};
let ConversionOptimizer = class {
  async trackPricingView(userId) { return true; }
};

// Try to load real services if available
try {
  AccessControl = require("./services/access-control");
  ConversionOptimizer = require("./services/conversion-optimizer");
  console.log("‚úÖ Service modules loaded");
} catch (error) {
  console.log("‚ö†Ô∏è Using fallback service modules");
}

// === ADVANCED LONG MESSAGE UTILITY FUNCTIONS ===
const MAX_MESSAGE_LENGTH = 4096;

/**
 * Split a long message into smaller chunks that fit Telegram's character limit
 * Preserves Khmer text formatting and line breaks
 */
function splitMessage(message, maxLength = 3500) { // Use 3500 to be safe with Khmer characters
  if (message.length <= maxLength) {
    return [message];
  }

  const chunks = [];
  let currentChunk = '';
  
  // Split by lines first to preserve formatting
  const lines = message.split('\n');
  
  for (const line of lines) {
    // If a single line is too long, split it by words
    if (line.length > maxLength) {
      if (currentChunk) {
        chunks.push(currentChunk.trim());
        currentChunk = '';
      }
      
      const words = line.split(' ');
      for (const word of words) {
        if ((currentChunk + ' ' + word).length > maxLength) {
          if (currentChunk) {
            chunks.push(currentChunk.trim());
            currentChunk = word;
          } else {
            // Single word is too long, force split
            chunks.push(word.substring(0, maxLength));
            currentChunk = word.substring(maxLength);
          }
        } else {
          currentChunk += (currentChunk ? ' ' : '') + word;
        }
      }
    } else {
      // Check if adding this line would exceed limit
      if ((currentChunk + '\n' + line).length > maxLength) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = line;
        } else {
          chunks.push(line);
        }
      } else {
        currentChunk += (currentChunk ? '\n' : '') + line;
      }
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }
  
  return chunks;
}

/**
 * Send a potentially long message as multiple chunks with proper Khmer support
 */
async function sendLongMessage(bot, chatId, text, options = {}, delay = 800) {
  try {
    const chunks = splitMessage(text, 3500); // Optimized for Khmer
    
    console.log(`üìù Sending long message in ${chunks.length} chunks to chat ${chatId}`);
    
    for (let i = 0; i < chunks.length; i++) {
      try {
        await bot.sendMessage(chatId, chunks[i], options);
        console.log(`‚úÖ Sent chunk ${i + 1}/${chunks.length} (${chunks[i].length} chars)`);
        
        // Add delay between chunks to avoid rate limiting
        if (i < chunks.length - 1 && delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error) {
        console.error(`‚ùå Error sending chunk ${i + 1}/${chunks.length}:`, error);
        throw error;
      }
    }
    
    console.log(`üéâ Successfully sent all ${chunks.length} chunks`);
  } catch (error) {
    console.error("‚ùå Error in sendLongMessage:", error);
    try {
      await bot.sendMessage(chatId, "‚ùå ·ûò·û∂·ûì·ûî·ûâ·üí·û†·û∂·ûÄ·üí·ûì·ûª·ûÑ·ûÄ·û∂·ûö·ûï·üí·ûâ·ûæ·ûü·û∂·ûö·üî ·ûü·ûº·ûò·ûë·û∂·ûÄ·üã·ûë·ûÑ @Chendasum");
    } catch (fallbackError) {
      console.error("‚ùå Failed to send error message:", fallbackError);
    }
  }
}

// === DUPLICATE PREVENTION (OPTIMIZED FOR WEBHOOK) ===
const processedMessages = new Set();
let lastProcessTime = {};

function isDuplicateMessage(msg) {
  const messageId = `${msg.chat.id}-${msg.message_id}`;
  const now = Date.now();

  // Only block if same message processed within last 3 seconds
  if (processedMessages.has(messageId) && 
      lastProcessTime[messageId] && 
      now - lastProcessTime[messageId] < 3000) {
    console.log(`[isDuplicateMessage] Blocking duplicate: ${messageId}`);
    return true;
  }

  processedMessages.add(messageId);
  lastProcessTime[messageId] = now;

  // Clean up old entries
  if (processedMessages.size > 50) {
    const cutoff = now - 30000;
    Object.keys(lastProcessTime).forEach((id) => {
      if (lastProcessTime[id] < cutoff) {
        processedMessages.delete(id);
        delete lastProcessTime[id];
      }
    });
  }


let bot = null;
const accessControl = new AccessControl();
const conversionOptimizer = new ConversionOptimizer();

if (process.env.BOT_TOKEN) {
  try {
    bot = new TelegramBot(process.env.BOT_TOKEN, { polling: false });
    console.log("‚úÖ Bot initialized");

    // === WEBHOOK HANDLER ===
    app.post(`/bot${process.env.BOT_TOKEN}`, async (req, res) => {
      try {
        console.log("üîî Webhook received");
        if (bot) {
          await bot.processUpdate(req.body);
        }
        res.sendStatus(200);
      } catch (error) {
        console.error("Webhook error:", error.message);
        res.sendStatus(500);
      }
    });

    // === COMMAND HANDLERS ===

    // /start COMMAND
    bot.onText(/\/start/i, async (msg) => {
      console.log("üöÄ [START] User:", msg.from.id);
      if (isDuplicateMessage(msg)) return;
      
      try {
        await startCommand.handle(msg, bot);
        console.log("‚úÖ [START] Processed successfully");
      } catch (error) {
        console.error("‚ùå [START] Error:", error.message);
        const welcomeMessage = `üåü ·ûü·ûº·ûò·ûü·üí·ûú·û∂·ûÇ·ûò·ûì·üç·ûò·ûÄ·ûÄ·û∂·ûì·üã 7-Day Money Flow Reset‚Ñ¢!

üí∞ ·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏·ûÇ·üí·ûö·ûî·üã·ûÇ·üí·ûö·ûÑ·ûõ·ûª·ûô ·üß ·ûê·üí·ûÑ·üÉ ·ûá·û∂·ûó·û∂·ûü·û∂·ûÅ·üí·ûò·üÇ·ûö

üéØ ·ûè·ûò·üí·ûõ·üÉ·ûñ·û∑·ûü·üÅ·ûü: $24 USD (·ûî·ûâ·üí·ûÖ·ûª·üá·ûñ·û∏ $47)
üì± ·ûî·üí·ûö·ûæ·ûî·üí·ûö·û∂·ûü·üã: /pricing ·ûä·ûæ·ûò·üí·ûî·û∏·ûò·ûæ·ûõ·ûõ·ûò·üí·û¢·û∑·ûè
üí≥ ·ûë·ûº·ûë·û∂·ûè·üã: /payment ·ûä·ûæ·ûò·üí·ûî·û∏·ûÖ·û∂·ûî·üã·ûï·üí·ûè·ûæ·ûò

üë®‚Äçüíº ·ûë·û∂·ûÄ·üã·ûë·ûÑ: @Chendasum ·ûü·ûò·üí·ûö·û∂·ûî·üã·ûá·üÜ·ûì·ûΩ·ûô

/help - ·ûá·üÜ·ûì·ûΩ·ûô·ûñ·üÅ·ûâ·ûõ·üÅ·ûâ`;
        await bot.sendMessage(msg.chat.id, welcomeMessage);
      }
    });

    // /help COMMAND
    bot.onText(/\/help/i, async (msg) => {
      console.log("üîß [HELP] User:", msg.from.id);
      if (isDuplicateMessage(msg)) return;
      
      try {
        const helpContent = await accessControl.getTierSpecificHelp(msg.from.id);
        await sendLongMessage(bot, msg.chat.id, helpContent, { parse_mode: "Markdown" });
        console.log("‚úÖ [HELP] Processed successfully");
      } catch (error) {
        console.error("‚ùå [HELP] Error:", error.message);
        const helpMessage = `üìã ·ûá·üÜ·ûì·ûΩ·ûô 7-Day Money Flow Reset‚Ñ¢

üéØ ·ûñ·û∂·ûÄ·üí·ûô·ûî·ûâ·üí·ûá·û∂·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì:
‚Ä¢ /start - ·ûÖ·û∂·ûî·üã·ûï·üí·ûè·ûæ·ûò
‚Ä¢ /pricing - ·ûò·ûæ·ûõ·ûè·ûò·üí·ûõ·üÉ ($24)
‚Ä¢ /payment - ·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã
‚Ä¢ /help - ·ûá·üÜ·ûì·ûΩ·ûô·ûì·üÅ·üá

üìö ·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏ ·üß ·ûê·üí·ûÑ·üÉ:
‚Ä¢ /day1 - ·ûü·üí·ûÇ·û∂·ûõ·üã Money Flow
‚Ä¢ /day2 - ·ûü·üí·ûú·üÇ·ûÑ·ûö·ûÄ Money Leaks
‚Ä¢ /day3 - ·ûú·û∂·ûô·ûè·ûò·üí·ûõ·üÉ·ûî·üí·ûö·ûñ·üê·ûì·üí·ûí
‚Ä¢ /day4 - ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûï·üÇ·ûì·ûë·û∏·ûõ·ûª·ûô
‚Ä¢ /day5 - Survival vs Growth
‚Ä¢ /day6 - ·ûö·üÄ·ûî·ûÖ·üÜ·ûï·üÇ·ûì·ûÄ·û∂·ûö
‚Ä¢ /day7 - Integration

üéØ Assessment ·û•·ûè·ûÇ·û∑·ûè·ûê·üí·ûõ·üÉ:
‚Ä¢ /financial_quiz - ·ûñ·û∑·ûì·û∑·ûè·üí·ûô·ûü·ûª·ûÅ·ûó·û∂·ûñ·û†·û∑·ûö·ûâ·üí·ûâ·ûú·ûè·üí·ûê·ûª
‚Ä¢ /calculate_daily - ·ûÇ·ûé·ûì·û∂·ûÖ·üÜ·ûé·û∂·ûô·ûî·üí·ûö·ûÖ·û∂·üÜ·ûê·üí·ûÑ·üÉ

üë®‚Äçüíº ·ûë·û∂·ûÄ·üã·ûë·ûÑ: @Chendasum ·ü¢·ü§/·üß
üåê Website: 7daymoneyflow.com`;
        await bot.sendMessage(msg.chat.id, helpMessage);
      }
    });

    // /pricing COMMAND
    bot.onText(/\/pricing/i, async (msg) => {
      console.log("üí∞ [PRICING] User:", msg.from.id);
      if (isDuplicateMessage(msg)) return;
      
      try {
        await paymentCommands.pricing(msg, bot);
        console.log("‚úÖ [PRICING] Processed successfully");
      } catch (error) {
        console.error("‚ùå [PRICING] Error:", error.message);
        const pricingMessage = `üí∞ 7-Day Money Flow Reset‚Ñ¢ - ·ûè·ûò·üí·ûõ·üÉ·ûñ·û∑·ûü·üÅ·ûü!

üéØ ·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏·ûü·û∂·ûò·ûâ·üí·ûâ (ESSENTIAL)
üíµ ·ûè·ûò·üí·ûõ·üÉ: $24 USD (·ûî·ûâ·üí·ûÖ·ûª·üá·ûñ·û∏ $47)
üéÅ ·ûü·ûì·üí·ûü·üÜ·ûî·û∂·ûì: $23 (50% ·ûî·ûâ·üí·ûÖ·ûª·üá!)

üìö ·û¢·üí·ûú·û∏·ûä·üÇ·ûõ·û¢·üí·ûì·ûÄ·ûë·ûë·ûΩ·ûõ·ûî·û∂·ûì:
‚úÖ ·ûò·üÅ·ûö·üÄ·ûì ·üß ·ûê·üí·ûÑ·üÉ·ûñ·üÅ·ûâ·ûõ·üÅ·ûâ
‚úÖ ·ûÄ·û∂·ûö·ûÇ·üí·ûö·ûî·üã·ûÇ·üí·ûö·ûÑ·ûõ·ûª·ûô·ûá·û∂·ûó·û∂·ûü·û∂·ûÅ·üí·ûò·üÇ·ûö
‚úÖ ·ûü·üí·ûú·üÇ·ûÑ·ûö·ûÄ Money Leaks
‚úÖ ·ûî·ûÑ·üí·ûÄ·ûæ·ûè·ûï·üÇ·ûì·ûÄ·û∂·ûö·û†·û∑·ûö·ûâ·üí·ûâ·ûú·ûè·üí·ûê·ûª
‚úÖ ·ûá·üÜ·ûì·ûΩ·ûô·ûñ·û∏ @Chendasum

üí≥ ·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã:
‚Ä¢ ABA Bank: 000 194 742
‚Ä¢ ACLEDA Bank: 092 798 169
‚Ä¢ Wing: 102 534 677

üö® ·ûè·ûò·üí·ûõ·üÉ·ûñ·û∑·ûü·üÅ·ûü·ûì·üÅ·üá·ûò·û∑·ûì·ûò·û∂·ûì·ûô·ûº·ûö·û°·ûæ·ûô!

üëâ /payment - ·ûÄ·û∂·ûö·ûé·üÇ·ûì·û∂·üÜ·ûë·ûº·ûë·û∂·ûè·üã·ûõ·ûò·üí·û¢·û∑·ûè
üë®‚Äçüíº ·ûë·û∂·ûÄ·üã·ûë·ûÑ: @Chendasum ·ûü·ûò·üí·ûö·û∂·ûî·üã·ûá·üÜ·ûì·ûΩ·ûô`;
        await bot.sendMessage(msg.chat.id, pricingMessage);
      }
    });

    // /payment COMMAND
    bot.onText(/\/payment/i, async (msg) => {
      console.log("üí≥ [PAYMENT] User:", msg.from.id);
      if (isDuplicateMessage(msg)) return;
      
      try {
        await paymentCommands.instructions(msg, bot);
        console.log("‚úÖ [PAYMENT] Processed successfully");
      } catch (error) {
        console.error("‚ùå [PAYMENT] Error:", error.message);
        const paymentMessage = `üí≥ ·ûÄ·û∂·ûö·ûé·üÇ·ûì·û∂·üÜ·ûë·ûº·ûë·û∂·ûè·üã

üè¶ ·ûí·ûì·û∂·ûÇ·û∂·ûö·ûä·üÇ·ûõ·û¢·û∂·ûÖ·ûî·üí·ûö·ûæ·ûî·û∂·ûì:
‚Ä¢ ABA Bank: 000 194 742
‚Ä¢ ACLEDA Bank: 092 798 169
‚Ä¢ Wing: 102 534 677
‚Ä¢ ·ûà·üí·ûò·üÑ·üá: SUM CHENDA

üí∞ ·ûÖ·üÜ·ûì·ûΩ·ûì·ûë·ûº·ûë·û∂·ûè·üã: $24 USD
üìù ·ûÖ·üÜ·ûé·û∂·üÜ: BOT${msg.from.id}

üì∏ ·ûî·ûì·üí·ûë·û∂·ûî·üã·ûñ·û∏·ûë·ûº·ûë·û∂·ûè·üã:
1. ·ûê·ûè·ûö·ûº·ûî·û¢·üÅ·ûÄ·üí·ûö·ûÑ·üã·ûî·ûâ·üí·ûá·û∂·ûÄ·üã·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã
2. ·ûï·üí·ûâ·ûæ·ûò·ûÄ @Chendasum
3. ·ûö·ûÑ·üã·ûÖ·û∂·üÜ·ûÄ·û∂·ûö·ûî·ûâ·üí·ûá·û∂·ûÄ·üã (·ü°-·ü¢ ·ûò·üâ·üÑ·ûÑ)

üë®‚Äçüíº ·ûá·üÜ·ûì·ûΩ·ûô: @Chendasum`;
        await bot.sendMessage(msg.chat.id, paymentMessage);
      }
    });

    // DAY COMMANDS (1-7)
    for (let day = 1; day <= 7; day++) {
      bot.onText(new RegExp(`/day${day}`, 'i'), async (msg) => {
        console.log(`üìö [DAY${day}] User:`, msg.from.id);
        if (isDuplicateMessage(msg)) return;
        
        try {
          // Check if user has paid
          const user = await User.findOne({ 
            $or: [
              { telegramId: msg.from.id },
              { telegram_id: msg.from.id }
            ]
          });
          
          const isPaid = user && (user.isPaid || user.is_paid === true || user.is_paid === 't');
          
          if (!isPaid) {
            const paymentRequiredMessage = `üîí ·ûê·üí·ûÑ·üÉ·ûë·û∏ ${day} ·ûè·üí·ûö·ûº·ûú·ûÄ·û∂·ûö·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã

üí∞ ·ûü·ûº·ûò·ûë·ûº·ûë·û∂·ûè·üã $24 USD ·ûä·ûæ·ûò·üí·ûî·û∏·ûÖ·ûº·ûõ·ûö·ûΩ·ûò·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏ ·üß ·ûê·üí·ûÑ·üÉ·ûñ·üÅ·ûâ·ûõ·üÅ·ûâ

üì± ·ûñ·û∑·ûì·û∑·ûè·üí·ûô·ûè·ûò·üí·ûõ·üÉ: /pricing
üí≥ ·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã: /payment

üéÅ ·ûî·ûì·üí·ûë·û∂·ûî·üã·ûñ·û∏·ûë·ûº·ûë·û∂·ûè·üã ·û¢·üí·ûì·ûÄ·ûì·ûπ·ûÑ·ûë·ûë·ûΩ·ûõ·ûî·û∂·ûì:
‚úÖ ·ûò·üÅ·ûö·üÄ·ûì·ûë·û∂·üÜ·ûÑ ·üß ·ûê·üí·ûÑ·üÉ
‚úÖ ·ûÄ·û∂·ûö·ûÇ·û∂·üÜ·ûë·üí·ûö·ûñ·û∏ @Chendasum
‚úÖ ·ûÄ·û∂·ûö·ûè·û∂·ûò·ûä·û∂·ûì·ûú·ûå·üí·ûç·ûì·ûó·û∂·ûñ

üë®‚Äçüíº ·ûá·üÜ·ûì·ûΩ·ûô: @Chendasum`;
            await bot.sendMessage(msg.chat.id, paymentRequiredMessage);
            return;
          }

          // Try to call full daily handler or use built-in content
          try {
            const match = [null, day.toString()];
            await dailyCommands.handle(msg, match, bot);
            console.log(`‚úÖ [DAY${day}] Full content delivered via handler`);
          } catch (handlerError) {
            console.error(`Handler error for day ${day}:`, handlerError);
            console.log(`üîÑ [DAY${day}] Using built-in content fallback`);
            
            // Built-in daily content with sendLongMessage support
            const dayContent = getDailyContent(day);
            await sendLongMessage(bot, msg.chat.id, dayContent, { parse_mode: "Markdown" });
            console.log(`‚úÖ [DAY${day}] Built-in content delivered successfully`);
          }
        } catch (error) {
          console.error(`‚ùå [DAY${day}] Error:`, error.message);
          await bot.sendMessage(msg.chat.id, `üîí ·ûü·ûº·ûò·ûë·ûº·ûë·û∂·ûè·üã·ûò·ûª·ûì·ûä·ûæ·ûò·üí·ûî·û∏·ûÖ·ûº·ûõ·ûî·üí·ûö·ûæ·ûê·üí·ûÑ·üÉ·ûë·û∏ ${day}·üî ·ûî·üí·ûö·ûæ /pricing ·ûä·ûæ·ûò·üí·ûî·û∏·ûò·ûæ·ûõ·ûñ·üê·ûè·üå·ûò·û∂·ûì·üî`);
        }
      });
    }

    // /vip COMMAND
    bot.onText(/\/vip/i, async (msg) => {
      console.log("üëë [VIP] User:", msg.from.id);
      if (isDuplicateMessage(msg)) return;
      
      try {
        const user = await User.findOne({ 
          $or: [
            { telegramId: msg.from.id },
            { telegram_id: msg.from.id }
          ]
        });
        
        const isPaid = user && (user.isPaid || user.is_paid === true || user.is_paid === 't');
        
        if (!isPaid) {
          const vipRequiresPaymentMessage = `üîí VIP Program ·ûè·üí·ûö·ûº·ûú·ûÄ·û∂·ûö·ûÄ·û∂·ûö·ûë·ûº·ûë·û∂·ûè·üã·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì·ûò·ûª·ûì

üí∞ ·ûá·üÜ·û†·û∂·ûì·ûë·û∏ ·ü°: ·ûë·ûº·ûë·û∂·ûè·üã·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì $24
üì± ·ûî·üí·ûö·ûæ /pricing ·ûä·ûæ·ûò·üí·ûî·û∏·ûò·ûæ·ûõ·ûñ·üê·ûè·üå·ûò·û∂·ûì

üëë ·ûá·üÜ·û†·û∂·ûì·ûë·û∏ ·ü¢: Upgrade ·ûë·üÖ VIP ($197)

üë®‚Äçüíº ·ûë·û∂·ûÄ·üã·ûë·ûÑ: @Chendasum ·ûü·ûò·üí·ûö·û∂·ûî·üã·ûñ·üê·ûè·üå·ûò·û∂·ûì·ûõ·ûò·üí·û¢·û∑·ûè`;
          await bot.sendMessage(msg.chat.id, vipRequiresPaymentMessage);
          return;
        }

        try {
          await vipCommands.info(msg, bot);
          console.log("‚úÖ [VIP] Full VIP info sent");
        } catch (handlerError) {
          console.error("VIP handler error:", handlerError);
          const vipMessage = `üëë VIP Program - ·û¢·üí·ûì·ûÄ·ûò·û∂·ûì·ûü·û∑·ûë·üí·ûí·û∑!

üåü ·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏ VIP ·ûö·ûΩ·ûò·ûò·û∂·ûì:
‚Ä¢ ·ûÄ·û∂·ûö·ûî·üí·ûö·ûπ·ûÄ·üí·ûü·û∂·ûï·üí·ûë·û∂·ûõ·üã·ûÅ·üí·ûõ·ûΩ·ûì 1-on-1
‚Ä¢ ·ûÄ·û∂·ûö·ûè·û∂·ûò·ûä·û∂·ûì·ûä·üÑ·ûô·ûï·üí·ûë·û∂·ûõ·üã
‚Ä¢ ·ûò·û∂·ûè·û∑·ûÄ·û∂·ûÄ·ûò·üí·ûö·û∑·ûè·ûÅ·üí·ûñ·ûü·üã 30 ·ûê·üí·ûÑ·üÉ
‚Ä¢ ·ûÄ·û∂·ûö·ûÇ·û∂·üÜ·ûë·üí·ûö·û¢·û∂·ûë·û∑·ûó·û∂·ûñ
‚Ä¢ Capital Strategy Sessions

üí∞ ·ûè·ûò·üí·ûõ·üÉ VIP: $197
üìû ·ûñ·û∑·ûÇ·üí·ûö·üÑ·üá: @Chendasum

‚úÖ ·û¢·üí·ûì·ûÄ·ûî·û∂·ûì·ûë·ûº·ûë·û∂·ûè·üã·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì·ûö·ûΩ·ûÖ·û†·ûæ·ûô
üëë ·ûü·ûö·ûü·üÅ·ûö "VIP APPLY" ·ûä·ûæ·ûò·üí·ûî·û∏·ûä·û∂·ûÄ·üã·ûñ·û∂·ûÄ·üí·ûô`;
          await bot.sendMessage(msg.chat.id, vipMessage);
        }
      } catch (error) {
        console.error("‚ùå [VIP] Error:", error.message);
        await bot.sendMessage(msg.chat.id, "üîí ·ûü·ûº·ûò·ûë·ûº·ûë·û∂·ûè·üã·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏·ûò·ûº·ûõ·ûä·üí·ûã·û∂·ûì·ûò·ûª·ûì·ûä·ûæ·ûò·üí·ûî·û∏·ûÖ·ûº·ûõ·ûî·üí·ûö·ûæ VIP·üî ·ûî·üí·ûö·ûæ /pricing");
      }
    });

    // ADMIN COMMANDS
    bot.onText(/\/admin_users/i, async (msg) => {
      if (isDuplicateMessage(msg)) return;
      try {
        await adminCommands.showUsers(msg, bot);
      } catch (e) {
        console.error("Error /admin_users:", e);
        await bot.sendMessage(msg.chat.id, "‚ùå ·ûò·û∂·ûì·ûî·ûâ·üí·û†·û∂·üî");
      }
    });

    bot.onText(/\/admin_analytics/i, async (msg) => {
      if (isDuplicateMessage(msg)) return;
      try {
        await adminCommands.showAnalytics(msg, bot);
      } catch (e) {
        console.error("Error /admin_analytics:", e);
        await bot.sendMessage(msg.chat.id, "‚ùå ·ûò·û∂·ûì·ûî·ûâ·üí·û†·û∂·üî");
      }
    });

    // QUOTE COMMANDS
    bot.onText(/\/quote$/i, async (msg) => {
      if (isDuplicateMessage(msg)) return;
      try {
        await quotesCommands.random(msg, bot);
      } catch (e) {
        console.error("Error /quote:", e);
        await bot.sendMessage(msg.chat.id, "üìù Quote coming soon...");
      }
    });

    // BADGE COMMANDS
    bot.onText(/\/badges/i, async (msg) => {
      if (isDuplicateMessage(msg)) return;
      try {
        await badgesCommands.show(msg, bot);
      } catch (e) {
        console.error("Error /badges:", e);
        await bot.sendMessage(msg.chat.id, "üèÜ Badges coming soon...");
      }
    });

    // /test COMMAND
    bot.onText(/\/test/i, async (msg) => {
      try {
        await bot.sendMessage(msg.chat.id, "‚úÖ Bot is working! All systems operational.");
        console.log("Test command sent to:", msg.from.id);
      } catch (error) {
        console.error("Test command error:", error.message);
      }
    });

    // VIP APPLY HANDLER
    bot.on("message", async (msg) => {
      if (!msg.text || msg.text.startsWith("/")) return;
      
      if (msg.text.toUpperCase() === "VIP APPLY") {
        try {
          const user = await User.findOne({ 
            $or: [
              { telegramId: msg.from.id },
              { telegram_id: msg.from.id }
            ]
          });

          const isPaid = user && (user.isPaid || user.is_paid === true || user.is_paid === 't');

          if (!isPaid) {
            await bot.sendMessage(msg.chat.id, "üîí ·ûü·ûº·ûò·ûë·ûº·ûë·û∂·ûè·üã·ûò·ûª·ûì·ûä·ûæ·ûò·üí·ûî·û∏·ûÖ·ûº·ûõ·ûö·ûΩ·ûò·ûÄ·ûò·üí·ûò·ûú·û∑·ûí·û∏ VIP·üî ·ûî·üí·ûö·ûæ /pricing");
            return;
          }
          
          await bot.sendMessage(msg.chat.id, `üåü VIP APPLICATION

·ûü·ûº·ûò·ûï·üí·ûâ·ûæ·ûñ·üê·ûè·üå·ûò·û∂·ûì:
1Ô∏è‚É£ ·ûà·üí·ûò·üÑ·üá·ûñ·üÅ·ûâ
2Ô∏è‚É£ ·û¢·û∂·ûá·û∏·ûú·ûÄ·ûò·üí·ûò
3Ô∏è‚É£ ·ûÇ·üÑ·ûõ·ûä·üÖ·û†·û∑·ûö·ûâ·üí·ûâ·ûú·ûè·üí·ûê·ûª
4Ô∏è‚É£ ·ûõ·üÅ·ûÅ·ûë·ûº·ûö·ûü·üê·ûñ·üí·ûë

üí∞ ·ûè·ûò·üí·ûõ·üÉ VIP: $197
üìû Admin ·ûì·ûπ·ûÑ·ûë·û∂·ûÄ·üã·ûë·ûÑ·û¢·üí·ûì·ûÄ`);
        } catch (error) {
          console.error("Error handling VIP APPLY:", error);
          await bot.sendMessage(msg.chat.id, "‚ùå ·ûò·û∂·ûì·ûî·ûâ·üí·û†·û∂·üî");
        }
      }
    });

    console.log("‚úÖ All bot commands registered");

  } catch (error) {
    console.error("‚ùå Bot initialization failed:", error.message);
  }
} else {
  console.error("‚ùå No BOT_TOKEN found");
}

// === BASIC HEALTH ROUTES ===
app.get("/", (req, res) => {
  console.log("Root endpoint hit");
  res.json({
    name: "7-Day Money Flow Reset‚Ñ¢ Telegram Bot",
    status: "Running",
    time: new Date().toISOString(),
    url: "7daysmoney-production.up.railway.app",
    features: [
      "7-Day Program Content",
      "Payment Processing", 
      "VIP Programs",
      "Progress Tracking",
      "Khmer Language Support"
    ]
  });
});

app.get("/health", (req, res) => {
  console.log("Health check");
  res.json({ 
    status: "OK", 
    time: new Date().toISOString(),
    bot_initialized: !!bot,
    environment: {
      NODE_ENV: process.env.NODE_ENV || "production",
      BOT_TOKEN: process.env.BOT_TOKEN ? "configured" : "missing",
      DATABASE_URL: process.env.DATABASE_URL ? "configured" : "missing"
    }
  });
});

// === WEBHOOK SETUP FOR RAILWAY ===
async function setupWebhook() {
  if (!bot || !process.env.BOT_TOKEN) {
    console.error("Cannot setup webhook - bot not initialized");
    return;
  }

  try {
    const webhookUrl = `https://7daysmoney-production.up.railway.app/bot${process.env.BOT_TOKEN}`;
    
    console.log("Setting webhook to:", webhookUrl);
    const result = await bot.setWebHook(webhookUrl);
    console.log("Webhook set result:", result);
  } catch (error) {
    console.error("Webhook setup error:", error);
  }
}

// === START SERVER ===
const PORT = process.env.PORT || 5000;
const HOST = "0.0.0.0";

const server = app.listen(PORT, HOST, async () => {
  console.log(`üöÄ Railway server running on ${HOST}:${PORT}`);
  console.log(`üåê URL: https://7daysmoney-production.up.railway.app`);
  console.log(`üéØ Features: Full 7-Day Program with Fallbacks`);
  
  // Setup webhook after server starts
  await setupWebhook();
});

// === GRACEFUL SHUTDOWN ===
process.on("SIGTERM", () => {
  console.log("SIGTERM received, shutting down gracefully");
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on("SIGINT", () => {
  console.log("SIGINT received, shutting down gracefully");  
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err.message);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', reason);
});
